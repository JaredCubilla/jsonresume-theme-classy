{
  "name": "z-schema",
  "description": "JSON schema validator",
  "version": "2.4.10",
  "dependencies": {
    "bluebird": ">=2.2.2",
    "request": ">=2.39.0"
  },
  "homepage": "https://github.com/zaggino/z-schema",
  "keywords": [
    "json",
    "schema",
    "validator"
  ],
  "license": "MIT",
  "author": {
    "name": "Martin Zagora",
    "email": "zaggino@gmail.com",
    "url": "https://github.com/zaggino"
  },
  "contributors": [
    {
      "name": "Martin Zagora",
      "email": "zaggino@gmail.com",
      "url": "https://github.com/zaggino"
    },
    {
      "name": "Oleksiy Krivoshey",
      "email": "oleksiyk@gmail.com",
      "url": "https://github.com/oleksiyk"
    },
    {
      "name": "Jurie-Jan Botha",
      "url": "https://github.com/juriejan"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/zaggino/z-schema.git"
  },
  "main": "src/ZSchema.js",
  "files": [
    "src/ZSchema.js",
    "src/ZSchema.min.js",
    "LICENSE",
    "README.md"
  ],
  "devDependencies": {
    "grunt": "latest",
    "grunt-contrib-uglify": "latest",
    "grunt-contrib-jshint": "latest",
    "grunt-simple-mocha": "latest",
    "chai": "latest",
    "mocha": "latest",
    "uglify-js": "latest",
    "mongodb": "latest"
  },
  "bugs": {
    "url": "https://github.com/zaggino/z-schema/issues",
    "email": "zaggino@gmail.com"
  },
  "scripts": {
    "prepublish": "grunt",
    "test": "grunt test"
  },
  "readme": "# z-schema validator\r\n\r\n[![NPM version](https://badge.fury.io/js/z-schema.png)](http://badge.fury.io/js/z-schema)\r\n[![Dependency Status](https://david-dm.org/zaggino/z-schema.png?theme=shields.io)](https://david-dm.org/zaggino/z-schema)\r\n\r\nJSON Schema validator for Node.js (draft4 version)\r\n\r\nCoded according to:\r\n\r\n[json-schema documentation](http://json-schema.org/documentation.html),\r\n[json-schema-core](http://json-schema.org/latest/json-schema-core.html),\r\n[json-schema-validation](http://json-schema.org/latest/json-schema-validation.html),\r\n[json-schema-hypermedia](http://json-schema.org/latest/json-schema-hypermedia.html)\r\n\r\nPassing all tests here (even optional, except zeroTerminatedFloats and some URI tests, see more info in [#18](https://github.com/zaggino/z-schema/issues/18)):\r\n\r\n[json-schema/JSON-Schema-Test-Suite](https://github.com/json-schema/JSON-Schema-Test-Suite)\r\n\r\nWill try to maintain this as much as possible, all bug reports welcome.\r\n\r\n### Grunt automatization\r\n\r\nIf you need to automatize validation of your schemas, there's a Grunt plugin [grunt-z-schema](https://github.com/petrbela/grunt-z-schema) by [Petr Bela](https://github.com/petrbela)\r\n\r\n### How does it compare to others?\r\n\r\n[rawgithub.com/zaggino/z-schema/master/benchmark/results.html](https://rawgithub.com/zaggino/z-schema/master/benchmark/results.html)\r\n\r\n## Basic Usage\r\n\r\n```javascript\r\nvar ZSchema = require(\"z-schema\");\r\n```\r\n\r\n```javascript\r\nZSchema.validate(json, schema)\r\n    .then(function(report){\r\n        // successful validation\r\n        // there might be warnings: console.log(report.warnings)\r\n    })\r\n    .catch(function(err){\r\n        console.error(err.errors)\r\n    })\r\n```\r\n\r\nThere is also support for _sync_ mode like this:\r\n```javascript\r\nvar validator = new ZSchema({ sync: true });\r\nvar valid = validator.validate(json, schema);\r\nif (!valid) {\r\n    var error = validator.getLastError();\r\n}\r\n```\r\n\r\nUsing traditional callback:\r\n```javascript\r\nZSchema.validate(json, schema, function(err, report){\r\n    if(err){\r\n        console.error(err.errors);\r\n        return;\r\n    }\r\n    // successful validation\r\n    // there might be warnings: console.log(report.warnings)\r\n})\r\n```\r\n\r\nIf you need just to validate your schema, you can do it like this:\r\n\r\n```javascript\r\nvar validator = new ZSchema();\r\nvalidator.validateSchema(schema)\r\n    .then(function(report){\r\n    })\r\n    .catch(function(err){\r\n    })\r\n```\r\n\r\nOr with Node.js style callback:\r\n\r\n```javascript\r\nvar validator = new ZSchema();\r\nvalidator.validateSchema(schema, function (err, report) {\r\n    if (err) ...\r\n});\r\n```\r\n\r\n## Remote references in schemas\r\n\r\nYour schemas can include remote references that should be real URIs ([more on that here](http://json-schema.org/latest/json-schema-core.html#anchor22))\r\nso validator can make a request and download the schema needed. Validator automatically\r\ncaches these remote requests so they are not repeated with every validation.\r\n\r\nIn case you don't have a real server or you'd like to load files from different location,\r\nyou can preload remote locations into the validator like this:\r\n\r\n```javascript\r\nvar fileContent = fs.readFileSync(__dirname + '/../json_schema_test_suite/remotes/integer.json', 'utf8');\r\nZSchema.setRemoteReference('http://localhost:1234/integer.json', fileContent);\r\n```\r\n\r\n```http://localhost:1234/integer.json``` doesn't have to be online now, all schemas\r\nreferencing it will validate against ```string``` that was passed to the function.\r\n\r\n## Advanced Usage\r\n\r\nYou can pre-compile schemas (for example on your server startup) so your application is not\r\nbothered by schema compilation and validation when validating ingoing / outgoing objects.\r\n\r\nPromises:\r\n\r\n```javascript\r\nvar validator = new ZSchema();\r\nvalidator.compileSchema(schema)\r\n    .then(function(compiledSchema){\r\n    })\r\n```\r\n\r\nOr callback:\r\n\r\n```javascript\r\nvar validator = new ZSchema();\r\nvalidator.compileSchema(schema, function (err, compiledSchema) {\r\n    assert.isUndefined(err);\r\n    ...\r\n});\r\n```\r\n\r\nThen you can re-use compiled schemas easily just the same way as non-compiled.\r\n\r\n```javascript\r\nvar validator = new ZSchema();\r\nvalidator.validate(json, compiledSchema)\r\n    .then(function(report){\r\n        // ...\r\n    })\r\n    .catch(function(err){\r\n        console.error(err.errors)\r\n    })\r\n```\r\n\r\n## Custom format validators\r\n\r\nYou can add validation for your own custom string formats like this:\r\n(these are added to all validator instances, because it would never make sense to have multiple\r\nfunctions to validate format with the same name)\r\n\r\n```javascript\r\nvar validator = new ZSchema();\r\n\r\nZSchema.registerFormat('xstring', function (str) {\r\n    return str === 'xxx'; // return true/false as a result of validation\r\n});\r\n\r\nvalidator.validate('xxx', {\r\n    'type': 'string',\r\n    'format': 'xstring'\r\n})\r\n.then(function(){})\r\n.catch(function(err){})\r\n```\r\n\r\nCustom validators can also be async:\r\n\r\nUsing promises:\r\n\r\n```javascript\r\nZSchema.registerFormat('xstring', function (str) {\r\n    return Q.delay(1000).thenResolve(return str === 'xxx'); // return a promise for validation result\r\n});\r\n```\r\n\r\nUsing classic callback:\r\n\r\n```javascript\r\nZSchema.registerFormat('xstring', function (str, callback) {\r\n    setTimeout(function(){\r\n        callback(null, str === 'xxx');\r\n        // or return custom error: callback(new Error('Bad, bad value!'))\r\n    }, 2000)\r\n});\r\n```\r\n\r\nAny exception thrown (or returned via classic callback) in custom validation function is written into validation error:\r\n```javascript\r\nZSchema.registerFormat('xstring', function (str) {\r\n    throw new Error('Bad, bad value!');\r\n});\r\n```\r\nAnd then expect errors to contain something like this:\r\n\r\n```\r\n[{ code: 'FORMAT',\r\n    message: 'xstring format validation failed: Error: Bad, bad value!',\r\n    path: '#/test',\r\n    params: { format: 'xstring', error: [Error: Bad, bad value!] } } ]\r\n```\r\n\r\n\r\n## Strict validation\r\n\r\nWhen creating new instance of validator, you can specify some options that will alter the validator behaviour like this:\r\n\r\n```javascript\r\nvar validator = new ZSchema({\r\n    option: true\r\n});\r\n```\r\n\r\n* noExtraKeywords: ```true/false```\r\n\r\nwhen true, do not allow unknown keywords in schema\r\n\r\n* noZeroLengthStrings: ```true/false```\r\n\r\nwhen true, always adds minLength: 1 to schemas where type is string\r\n\r\n* noTypeless: ```true/false```\r\n\r\nwhen true, every schema must specify a type\r\n\r\n* forceAdditional: ```true/false```\r\n\r\nwhen true, forces not to leave out some keys on schemas (additionalProperties, additionalItems)\r\n\r\n* forceProperties: ```true/false```\r\n\r\nwhen true, forces not to leave out properties or patternProperties on type-object schemas\r\n\r\n* forceItems: ```true/false```\r\n\r\nwhen true, forces not to leave out items on array-type schemas\r\n\r\n* forceMaxLength: ```true/false```\r\n\r\nwhen true, forces not to leave out maxLength on string-type schemas, when format or enum is not specified\r\n\r\n__Alternatively__, you can turn on all of the above options with:\r\n\r\n```javascript\r\nvar validator = new ZSchema({\r\n    strict: true\r\n});\r\n```\r\n\r\n## More options\r\n\r\n* noSchemaCache: ```true/false```\r\n\r\nwhen true, disables caching of compiled schemas - cache is used to resolve references to other schemas by their ID\r\n\r\n* strictUris: ```true/false```\r\n\r\nwhen true, uris need to be in full rfc3986 format, by default checks for uri-fragment, more info in [#18](https://github.com/zaggino/z-schema/issues/18)\r\n\r\n* strictEmails: ```true/false```\r\n\r\nwhen true, emails are validated more strictly with a defined list of allowed top level domains, more info in [#48](https://github.com/zaggino/z-schema/issues/48)\r\n\r\n# Pull requests\r\n\r\nAvoid JSHint errors - settings for the JSHint are specified in ```.jshintrc```.\r\nYou can check for errors using ```grunt``` command which runs both jshint and mocha tests.\r\nPlease check for errors before opening any pull requests.\r\n\r\n# Credits\r\n\r\n* Written by Martin Zagora, <zaggino@gmail.com>\r\n* Thanks to Oleksiy Krivoshey, <oleksiyk@gmail.com> for refactoring and new API (version 2.x) and bugfixing\r\n",
  "readmeFilename": "README.md",
  "_id": "z-schema@2.4.10",
  "_from": "z-schema@~2.4.8"
}
